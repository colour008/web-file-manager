<!DOCTYPE html>
<html lang="zh-CN">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>æ–‡ä»¶ç®¡ç†å™¨ï¼ˆä¼˜åŒ–ç‰ˆï¼‰</title>
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" />
		<style>
			/* å…¨å±€æ ·å¼é‡ç½® */
			* {
				margin: 0;
				padding: 0;
				box-sizing: border-box;
				font-family: 'Microsoft YaHei', 'Segoe UI', sans-serif;
			}
			body {
				display: flex;
				height: 100vh;
				overflow: hidden;
				background: #f0f2f5;
				color: #333;
			}

			/* ç§»åŠ¨ç«¯ä¾§è¾¹æ åˆ‡æ¢æŒ‰é’® */
			.sidebar-toggle {
				display: none;
				position: fixed;
				top: 10px;
				left: 10px;
				z-index: 1001;
				padding: 8px;
				background: #0078d7;
				color: white;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				transition: background-color 0.2s;
			}
			.sidebar-toggle:hover {
				background: #005a9e;
			}

			/* å‰ªè´´æ¿æç¤º */
			.clipboard-tip {
				position: fixed;
				top: 10px;
				right: 10px;
				padding: 8px 12px;
				background: rgba(0, 120, 215, 0.9);
				color: white;
				border-radius: 4px;
				font-size: 12px;
				z-index: 9998;
				display: none;
			}

			/* å·¦ä¾§ä¾§è¾¹æ  */
			.sidebar {
				width: 380px;
				background: #ffffff;
				border-right: 1px solid #e5e7eb;
				padding: 20px;
				display: flex;
				flex-direction: column;
				gap: 12px;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
				transition: width 0.3s ease;
				overflow: hidden;
			}
			.sidebar-title {
				font-size: 18px;
				font-weight: 600;
				color: #1f2937;
				margin-bottom: 5px;
			}
			.tip-text {
				font-size: 13px;
				color: #6b7280;
				line-height: 1.4;
			}
			.path-input {
				padding: 10px 12px;
				border: 1px solid #d1d5db;
				border-radius: 6px;
				font-size: 14px;
				transition: border-color 0.2s;
			}
			.path-input:focus {
				outline: none;
				border-color: #0078d7;
				box-shadow: 0 0 0 2px rgba(0, 120, 215, 0.1);
			}
			.confirm-btn {
				padding: 8px 12px;
				border: none;
				border-radius: 6px;
				background: #0078d7;
				color: white;
				font-size: 13px;
				font-weight: 500;
				cursor: pointer;
				transition: background-color 0.2s;
			}
			.confirm-btn:hover {
				background: #005a9e;
			}
			.confirm-btn:active {
				background: #004a80;
			}
			.back-btn-sidebar {
				padding: 6px 10px;
				background: #f9fafb;
				border: 1px solid #d1d5db;
				border-radius: 6px;
				cursor: pointer;
				font-size: 12px;
				color: #374151;
				transition: all 0.2s;
			}
			.back-btn-sidebar:hover {
				background: #f3f4f6;
			}
			.back-btn-sidebar:disabled {
				background: #f9fafb;
				cursor: not-allowed;
				color: #9ca3af;
				border-color: #e5e7eb;
			}

			/* çº§è”ç›®å½•æ ‘æ ·å¼ï¼ˆæ”¯æŒç›®å½•+æ–‡ä»¶æ˜¾ç¤ºï¼‰ */
			.tree-container {
				flex: 1;
				overflow-y: auto;
				margin-top: 8px;
				padding-right: 5px;
				position: relative;
			}
			.tree-container::-webkit-scrollbar {
				width: 6px;
			}
			.tree-container::-webkit-scrollbar-thumb {
				background: #d1d5db;
				border-radius: 3px;
			}
			.tree-node-wrapper {
				position: relative;
				padding-left: 20px;
				line-height: 28px;
			}
			/* çº§è”çº¿æ ·å¼ */
			.tree-node-wrapper::before {
				content: '';
				position: absolute;
				top: 0;
				left: 8px;
				height: 100%;
				width: 1px;
				background-color: #e5e7eb;
			}
			.tree-node-wrapper::after {
				content: '';
				position: absolute;
				top: 14px;
				left: 8px;
				width: 12px;
				height: 1px;
				background-color: #e5e7eb;
			}
			.tree-node-wrapper:last-child::before {
				height: 14px;
			}
			/* é€šç”¨èŠ‚ç‚¹æ ·å¼ï¼ˆç›®å½•+æ–‡ä»¶ï¼‰ */
			.tree-node {
				padding: 4px 8px;
				cursor: pointer;
				border-radius: 4px;
				display: flex;
				align-items: center;
				gap: 6px;
				font-size: 14px;
				transition: all 0.2s ease; /* å¹³æ»‘è¿‡æ¸¡ */
			}
			.tree-node:hover {
				background: #e8f4fd; /* æ˜æ˜¾çš„æµ…è“è‰²èƒŒæ™¯ */
				transform: translateX(2px); /* è½»å¾®å³ç§»åŠ¨æ•ˆ */
				box-shadow: 0 1px 2px rgba(0, 120, 215, 0.1); /* è½»å¾®é˜´å½± */
			}
			.tree-node.active {
				background: #0078d7;
				color: white;
			}
			/* ç›®å½•èŠ‚ç‚¹ä¸“å±æ ·å¼ */
			.tree-node.dir .toggle-icon {
				font-size: 10px;
				cursor: pointer;
				user-select: none;
				width: 12px;
				height: 12px;
				display: inline-flex;
				align-items: center;
				justify-content: center;
			}
			.tree-node.dir .node-icon {
				font-size: 14px;
				color: #f5a623; /* ç›®å½•å›¾æ ‡æ©™è‰² */
			}
			/* æ–‡ä»¶èŠ‚ç‚¹ä¸“å±æ ·å¼ */
			.tree-node.file .toggle-icon {
				visibility: hidden; /* æ–‡ä»¶æ— æŠ˜å æŒ‰é’® */
				width: 12px;
			}
			.tree-node.file .node-icon {
				font-size: 14px;
				color: #666; /* æ–‡ä»¶å›¾æ ‡ç°è‰² */
			}
			.tree-node .node-name {
				flex: 1;
			}
			/* å­èŠ‚ç‚¹å®¹å™¨ï¼ˆå‘ä¸‹å±•å¼€ï¼‰ */
			.tree-children {
				max-height: 0;
				overflow: hidden;
				transition: max-height 0.3s ease-in-out;
			}
			.tree-children.show {
				max-height: 2000px; /* è¶³å¤Ÿå¤§çš„é«˜åº¦å®¹çº³å­èŠ‚ç‚¹ */
			}

			/* å³ä¾§å†…å®¹åŒº */
			.content {
				flex: 1;
				padding: 25px;
				overflow-y: auto;
			}
			/* è·¯å¾„+æœç´¢+æŒ‰é’®å¸ƒå±€ - æ ¸å¿ƒè°ƒæ•´ */
			.content-header {
				display: flex;
				align-items: center;
				gap: 10px;
				margin-bottom: 20px;
				flex-wrap: nowrap;
				background: #ffffff;
				border-radius: 8px;
				padding: 0 10px;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
			}
			/* è¿”å›ä¸Šçº§æŒ‰é’®ç§»åˆ°è·¯å¾„å‰ */
			.back-btn-content {
				padding: 12px 10px;
				background: transparent;
				border: none;
				cursor: pointer;
				font-size: 14px;
				color: #374151;
				transition: all 0.2s ease; /* å¹³æ»‘è¿‡æ¸¡ */
			}
			.back-btn-content:hover {
				color: #0078d7;
				transform: scale(1.1); /* è½»å¾®æ”¾å¤§ */
			}
			.back-btn-content:disabled {
				color: #9ca3af;
				cursor: not-allowed;
				transform: none; /* ç¦ç”¨æ—¶å–æ¶ˆæ”¾å¤§ */
			}
			/* è·¯å¾„+æœç´¢æ•´åˆå®¹å™¨ */
			.path-search-container {
				flex: 1;
				display: flex;
				align-items: center;
				gap: 10px;
				padding: 12px 0;
			}
			.path-bar {
				font-size: 14px;
				color: #1f2937;
				white-space: nowrap;
				overflow: hidden;
				text-overflow: ellipsis;
			}
			/* æœç´¢æ¡†åµŒå…¥è·¯å¾„å†… */
			.search-input {
				padding: 6px 10px;
				border: 1px solid #d1d5db;
				border-radius: 4px;
				font-size: 13px;
				width: 200px;
				transition: all 0.2s ease; /* å¹³æ»‘è¿‡æ¸¡ */
			}
			.search-input:focus {
				outline: none;
				border-color: #0078d7;
				box-shadow: 0 0 0 2px rgba(0, 120, 215, 0.1);
				transform: scale(1.02); /* è½»å¾®æ”¾å¤§ */
			}
			/* è§†å›¾åˆ‡æ¢æŒ‰é’® */
			.view-toggle-btn {
				padding: 12px 15px;
				background: transparent;
				border: none;
				border-radius: 4px;
				cursor: pointer;
				font-size: 13px;
				color: #374151;
				transition: all 0.2s ease; /* å¹³æ»‘è¿‡æ¸¡ */
			}
			.view-toggle-btn.active {
				background: #0078d7;
				color: white;
			}
			.view-toggle-btn:hover:not(.active) {
				background: #f3f4f6;
				transform: translateY(-1px); /* è½»å¾®ä¸Šç§» */
				box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
			}

			/* ç®€æ´å¡ç‰‡è§†å›¾æ ·å¼ï¼ˆå¢å¼ºhoveræ•ˆæœï¼‰ */
			.file-list-card {
				display: grid;
				grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
				gap: 15px 8px;
				padding: 10px 0;
			}
			.file-item-card {
				display: flex;
				flex-direction: column;
				align-items: center;
				padding: 8px 5px; /* å¢åŠ å†…è¾¹è· */
				background: transparent;
				border: 1px solid transparent; /* é€æ˜è¾¹æ¡†ï¼ˆhoveræ—¶æ˜¾ç¤ºï¼‰ */
				border-radius: 6px; /* åœ†è§’ */
				cursor: pointer;
				transition: all 0.25s ease; /* æ›´é•¿çš„è¿‡æ¸¡æ—¶é—´ï¼Œæ›´ä¸æ»‘ */
				min-height: 80px;
				position: relative;
			}
			/* å¢å¼ºhoveræ ·å¼ */
			.file-item-card:hover {
				background: #e8f4fd; /* æ˜æ˜¾çš„æµ…è“è‰²èƒŒæ™¯ */
				border-color: #0078d7; /* è“è‰²è¾¹æ¡† */
				transform: translateY(-3px) scale(1.03); /* ä¸Šç§»+è½»å¾®æ”¾å¤§ */
				box-shadow: 0 4px 8px rgba(0, 120, 215, 0.15); /* æ˜ç¡®çš„é˜´å½± */
			}
			/* é€‰ä¸­çŠ¶æ€ä¹Ÿå¢å¼º */
			.file-item-card.selected {
				background: #d7e9f7;
				border-color: #005a9e;
			}
			/* å›¾æ ‡åº“æ ·å¼ */
			.item-icon {
				font-size: 32px;
				margin-bottom: 5px;
				transition: all 0.2s ease; /* å›¾æ ‡åŠ¨æ•ˆ */
			}
			.file-item-card:hover .item-icon {
				transform: scale(1.1); /* å›¾æ ‡æ”¾å¤§ */
				filter: brightness(1.1); /* å›¾æ ‡äº®åº¦æå‡ */
			}
			/* ä¸åŒæ–‡ä»¶ç±»å‹å›¾æ ‡åŒºåˆ† */
			.item-icon.dir {
				color: #f5a623;
			}
			.item-icon.file.txt {
				color: #666;
			}
			.item-icon.file.doc,
			.item-icon.file.docx {
				color: #2b579a;
			}
			.item-icon.file.xls,
			.item-icon.file.xlsx {
				color: #217346;
			}
			.item-icon.file.ppt,
			.item-icon.file.pptx {
				color: #d24726;
			}
			.item-icon.file.pdf {
				color: #e3342f;
			}
			.item-icon.file.png,
			.item-icon.file.jpg,
			.item-icon.file.jpeg {
				color: #f05032;
			}
			.item-icon.file.mp4,
			.item-icon.file.avi,
			.item-icon.file.mov {
				color: #ff6b35;
			}
			.item-icon.file.mp3,
			.item-icon.file.wav {
				color: #7c4dff;
			}
			.item-icon.file[data-ext='zip'],
			.item-icon.file[data-ext='rar'],
			.item-icon.file[data-ext='7z'] {
				color: #ffa500;
			}
			.item-icon.file.exe {
				color: #0078d7;
			}
			.item-icon.file.link {
				color: #9c27b0;
			}
			.item-name {
				font-size: 12px;
				text-align: center;
				white-space: normal;
				word-wrap: break-word;
				overflow: hidden;
				text-overflow: ellipsis;
				width: 100%;
				color: #374151;
				line-height: 1.2;
				max-height: 2.4em;
				transition: color 0.2s ease; /* æ–‡å­—é¢œè‰²è¿‡æ¸¡ */
			}
			.file-item-card:hover .item-name {
				color: #0078d7; /* æ–‡å­—å˜è“è‰² */
				font-weight: 500; /* æ–‡å­—åŠ ç²— */
			}

			/* åˆ—è¡¨è§†å›¾æ ·å¼ï¼ˆå¢å¼ºhoveræ•ˆæœï¼‰ */
			.file-list-list {
				width: 100%;
				border-collapse: collapse;
				background: #ffffff;
				border-radius: 8px;
				overflow: hidden;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
			}
			.file-list-list th {
				padding: 12px 15px;
				text-align: left;
				border-bottom: 1px solid #e5e7eb;
				background: #f9fafb;
				font-size: 13px;
				font-weight: 600;
				color: #1f2937;
				cursor: pointer;
				position: relative;
				transition: all 0.2s ease;
			}
			.file-list-list th:hover {
				background: #f3f4f6;
			}
			.file-list-list th .sort-arrow {
				margin-left: 6px;
				font-size: 10px;
				opacity: 0.5;
			}
			.file-list-list th.active .sort-arrow {
				opacity: 1;
			}
			.file-list-list td {
				padding: 12px 15px;
				text-align: left;
				border-bottom: 1px solid #e5e7eb;
				font-size: 13px;
				color: #374151;
				transition: all 0.2s ease; /* å•å…ƒæ ¼è¿‡æ¸¡ */
			}
			.file-list-list tr.dir td {
				color: #f5a623;
				font-weight: 500;
			}
			/* å¢å¼ºåˆ—è¡¨è¡Œhoveræ ·å¼ */
			.file-list-list tr:hover {
				background: #e8f4fd; /* æ˜æ˜¾çš„æµ…è“è‰²èƒŒæ™¯ */
				transform: scale(1.005); /* è½»å¾®æ”¾å¤§ */
				box-shadow: 0 2px 6px rgba(0, 120, 215, 0.1); /* é˜´å½± */
			}
			/* åˆ—è¡¨è¡Œhoveræ—¶æ–‡å­—å˜è‰² */
			.file-list-list tr:hover td {
				color: #0078d7;
				font-weight: 500;
			}
			/* åˆ—è¡¨é€‰ä¸­è¡Œæ ·å¼ */
			.file-list-list tr.selected {
				background: #d7e9f7;
			}
			.list-item-icon {
				font-size: 18px;
				margin-right: 8px;
				transition: all 0.2s ease;
			}
			.file-list-list tr:hover .list-item-icon {
				transform: scale(1.2); /* å›¾æ ‡æ”¾å¤§ */
				filter: brightness(1.1);
			}
			.file-size {
				color: #6b7280;
			}
			.file-mtime {
				color: #6b7280;
			}

			/* æç¤ºæ ·å¼ */
			.empty-tip,
			.error-tip {
				text-align: center;
				padding: 50px 0;
				font-size: 15px;
			}
			.empty-tip {
				color: #6b7280;
			}
			.error-tip {
				color: #dc2626;
			}
			.search-empty-tip {
				text-align: center;
				padding: 20px 0;
				font-size: 13px;
				color: #6b7280;
			}

			/* å³é”®èœå•æ ¸å¿ƒæ ·å¼ï¼ˆå¢å¼ºhoverï¼‰ */
			.context-menu {
				position: fixed;
				width: 180px;
				background: #ffffff;
				border: 1px solid #e5e7eb;
				border-radius: 6px;
				box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
				z-index: 9999;
				display: none;
			}
			.context-menu-item {
				padding: 8px 12px;
				font-size: 13px;
				cursor: pointer;
				display: flex;
				align-items: center;
				gap: 8px;
				transition: all 0.2s ease;
			}
			.context-menu-item:hover {
				background: #0078d7;
				color: white;
				transform: translateX(2px); /* è½»å¾®å³ç§» */
			}
			.context-menu-separator {
				height: 1px;
				background: #e5e7eb;
				margin: 4px 0;
			}
			.context-menu-icon {
				font-size: 14px;
			}

			/* æ‰¹é‡æ“ä½œå·¥å…·æ  */
			.batch-actions {
				display: flex;
				align-items: center;
				gap: 10px;
				padding: 10px;
				background: #f0f2f5;
				border-radius: 8px;
				margin-bottom: 15px;
				display: none;
			}

			.batch-actions span {
				font-size: 14px;
				color: #374151;
			}

			.batch-action-btn {
				padding: 6px 10px;
				border: none;
				border-radius: 4px;
				background: #0078d7;
				color: white;
				cursor: pointer;
				font-size: 12px;
			}

			.batch-action-btn:hover {
				background: #005a9e;
			}

			/* åŠ è½½åŠ¨ç”» */
			.loading-overlay {
				position: fixed;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				background: rgba(0, 0, 0, 0.5);
				display: flex;
				justify-content: center;
				align-items: center;
				z-index: 10000;
				display: none;
			}

			.loading-spinner {
				width: 50px;
				height: 50px;
				border: 5px solid #f3f3f3;
				border-top: 5px solid #0078d7;
				border-radius: 50%;
				animation: spin 1s linear infinite;
			}

			@keyframes spin {
				0% {
					transform: rotate(0deg);
				}
				100% {
					transform: rotate(360deg);
				}
			}

			.loading-text {
				color: white;
				margin-left: 15px;
				font-size: 16px;
			}

			/* æ‹–æ‹½ä¸Šä¼ æ ·å¼ */
			.dragover {
				border: 2px dashed #0078d7 !important;
				background-color: rgba(0, 120, 215, 0.1) !important;
			}

			/* å“åº”å¼è®¾è®¡ */
			@media (max-width: 768px) {
				.sidebar-toggle {
					display: block;
				}
				.sidebar {
					width: 0;
					position: absolute;
					z-index: 1000;
				}
				.content {
					padding: 15px;
				}
				.file-list-card {
					grid-template-columns: repeat(auto-fill, minmax(80px, 1fr));
					gap: 10px 5px;
				}
				.content-header {
					flex-wrap: wrap;
				}
				.search-input {
					width: 150px;
				}
			}
		</style>
	</head>
	<body>
		<!-- ç§»åŠ¨ç«¯ä¾§è¾¹æ åˆ‡æ¢æŒ‰é’® -->
		<button class="sidebar-toggle" id="sidebarToggle">
			<i class="fa-solid fa-bars"></i>
		</button>

		<!-- å‰ªè´´æ¿æç¤º -->
		<div class="clipboard-tip" id="clipboardTip"></div>

		<div class="sidebar" id="sidebar">
			<div class="sidebar-title">æ–‡ä»¶ç®¡ç†å™¨</div>
			<div class="tip-text">
				ğŸ’¡ å¤åˆ¶æ–‡ä»¶å¤¹ç»å¯¹è·¯å¾„ç²˜è´´è‡³ä¸‹æ–¹<br />ç¤ºä¾‹ï¼šC:\Users\ä½ çš„ç”¨æˆ·å\Desktop
				æˆ– D:\test
			</div>
			<input
				type="text"
				class="path-input"
				id="pathInput"
				placeholder="è¯·è¾“å…¥æ–‡ä»¶å¤¹ç»å¯¹è·¯å¾„" />
			<button class="confirm-btn" id="confirmBtn">ç¡®è®¤åŠ è½½</button>
			<button class="back-btn-sidebar" id="backBtnSidebar" disabled>
				â† è¿”å›ä¸Šçº§ç›®å½•
			</button>
			<div class="tree-container" id="dirTree">
				<div class="empty-tip">è¯·è¾“å…¥æ–‡ä»¶å¤¹ç»å¯¹è·¯å¾„å¹¶ç¡®è®¤</div>
			</div>
		</div>
		<div class="content">
			<!-- è·¯å¾„+æœç´¢+æŒ‰é’®å¸ƒå±€è°ƒæ•´ -->
			<div class="content-header">
				<button class="back-btn-content" id="backBtnContent" disabled>
					â†
				</button>
				<div class="path-search-container">
					<div class="path-bar" id="pathBar">
						å½“å‰è·¯å¾„ï¼šæœªé€‰æ‹©æ–‡ä»¶å¤¹
					</div>
					<input
						type="text"
						class="search-input"
						id="searchInput"
						placeholder="æœç´¢åç§°..." />
				</div>
				<button class="view-toggle-btn active" id="cardViewBtn">
					å¡ç‰‡è§†å›¾
				</button>
				<button class="view-toggle-btn" id="listViewBtn">
					åˆ—è¡¨è§†å›¾
				</button>
				<!-- æ–°å¢ï¼šå¯¼å‡ºExcelæŒ‰é’® -->
				<button
					class="view-toggle-btn"
					id="exportExcelBtn"
					style="display: none">
					<i class="fa-solid fa-file-excel"></i> å¯¼å‡ºExcel
				</button>
			</div>

			<!-- æ‰¹é‡æ“ä½œå·¥å…·æ  -->
			<div class="batch-actions" id="batchActions">
				<span class="batch-count">å·²é€‰æ‹© <strong>0</strong> é¡¹</span>
				<button class="batch-action-btn" id="batchDeleteBtn">
					åˆ é™¤
				</button>
				<button class="batch-action-btn" id="batchCopyBtn">å¤åˆ¶</button>
				<button class="batch-action-btn" id="batchMoveBtn">ç§»åŠ¨</button>
			</div>

			<div id="fileDisplayArea">
				<div class="empty-tip">è¯·è¾“å…¥æ–‡ä»¶å¤¹ç»å¯¹è·¯å¾„å¹¶åŠ è½½å†…å®¹</div>
			</div>
		</div>

		<!-- å³é”®èœå• DOMï¼ˆåŒ…å«é‡å‘½å/åˆ é™¤ï¼‰ -->
		<div class="context-menu" id="contextMenu">
			<div class="context-menu-item" id="menuOpen">
				<i class="context-menu-icon fa-solid fa-folder-open"></i>
				<span>æ‰“å¼€</span>
			</div>
			<div class="context-menu-separator"></div>
			<div class="context-menu-item" id="menuRename">
				<i class="context-menu-icon fa-solid fa-pen-to-square"></i>
				<span>é‡å‘½å</span>
			</div>
			<div class="context-menu-item" id="menuDelete">
				<i class="context-menu-icon fa-solid fa-trash-can"></i>
				<span>åˆ é™¤</span>
			</div>
			<div class="context-menu-separator"></div>
			<div class="context-menu-item" id="menuNewFolder">
				<i class="context-menu-icon fa-solid fa-folder-plus"></i>
				<span>æ–°å»ºæ–‡ä»¶å¤¹</span>
			</div>
			<div class="context-menu-item" id="menuNewFile">
				<i class="context-menu-icon fa-solid fa-file"></i>
				<span>æ–°å»ºæ–‡ä»¶</span>
			</div>
			<div class="context-menu-separator"></div>
			<div class="context-menu-item" id="menuCopy">
				<i class="context-menu-icon fa-solid fa-copy"></i>
				<span>å¤åˆ¶</span>
			</div>
			<div class="context-menu-item" id="menuCut">
				<i class="context-menu-icon fa-solid fa-cut"></i>
				<span>å‰ªåˆ‡</span>
			</div>
			<div class="context-menu-item" id="menuPaste">
				<i class="context-menu-icon fa-solid fa-paste"></i>
				<span>ç²˜è´´</span>
			</div>
		</div>

		<!-- åŠ è½½åŠ¨ç”» -->
		<div class="loading-overlay" id="loadingOverlay">
			<div class="loading-spinner"></div>
			<div class="loading-text">åŠ è½½ä¸­...</div>
		</div>

		<script>
			const baseUrl = 'http://localhost:3001/api';
			// å…¨å±€é…ç½®ï¼šéšè—æ–‡ä»¶è¿‡æ»¤è§„åˆ™
			const HIDDEN_FILE_PATTERNS = [
				// ç‰¹æ®Šä¸´æ—¶æ–‡ä»¶ï¼ˆå¦‚ Word ä¸´æ—¶æ–‡ä»¶ï¼‰
				/^~/,
				// Windows ç³»ç»Ÿæ–‡ä»¶
				/^desktop\.ini$/,
				/\.sys$/,
				/\.bak$/,
				// Linux/Mac éšè—æ–‡ä»¶ï¼ˆ. å¼€å¤´ï¼‰
				/^\./,
				// å…¶ä»–ç‰¹æ®Šéšè—æ–‡ä»¶
				/^Thumbs\.db$/,
			];

			// åˆ¤æ–­æ˜¯å¦ä¸ºéšè—æ–‡ä»¶
			function isHiddenFile(fileName) {
				return HIDDEN_FILE_PATTERNS.some((pattern) =>
					pattern.test(fileName)
				);
			}

			let currentPath = '';
			let parentPath = '';
			let currentViewMode = 'card';
			let fileDataCache = {};
			let sortConfig = { field: '', direction: '', original: [] };
			let searchKeyword = '';
			let currentContextItem = null;
			let selectedItems = [];
			let clipboard = null;
			let clipboardAction = null; // 'copy' or 'cut'
			const contextMenu = document.getElementById('contextMenu');

			// å‰ç«¯è·¯å¾„å¤„ç†å·¥å…·å‡½æ•°ï¼ˆæ›¿ä»£Node.jsçš„pathæ¨¡å—ï¼‰
			const pathUtils = {
				dirname: function (path) {
					const normalized = path
						.replace(/\\/g, '/')
						.replace(/\/$/, '');
					const lastSlash = normalized.lastIndexOf('/');
					return lastSlash === -1
						? '.'
						: normalized.substring(0, lastSlash);
				},
				join: function (...paths) {
					const joined = paths.join('/').replace(/\\/g, '/');
					return joined.replace(/\/+/g, '/');
				},
				basename: function (path) {
					const normalized = path
						.replace(/\\/g, '/')
						.replace(/\/$/, '');
					const lastSlash = normalized.lastIndexOf('/');
					return lastSlash === -1
						? normalized
						: normalized.substring(lastSlash + 1);
				},
			};

			// åˆå§‹åŒ–äº‹ä»¶ç»‘å®š
			document
				.getElementById('confirmBtn')
				.addEventListener('click', loadPathData);
			document
				.getElementById('backBtnSidebar')
				.addEventListener('click', goBack);
			document
				.getElementById('backBtnContent')
				.addEventListener('click', goBack);
			document
				.getElementById('cardViewBtn')
				.addEventListener('click', () => switchViewMode('card'));
			document
				.getElementById('listViewBtn')
				.addEventListener('click', () => switchViewMode('list'));
			document
				.getElementById('pathInput')
				.addEventListener(
					'keydown',
					(e) => e.key === 'Enter' && loadPathData()
				);
			document
				.getElementById('searchInput')
				.addEventListener('input', (e) => {
					searchKeyword = e.target.value.trim().toLowerCase();
					filterAndRenderFiles();
				});

			// æ–°å¢ï¼šå¯¼å‡ºExceläº‹ä»¶
			document
				.getElementById('exportExcelBtn')
				.addEventListener('click', exportToExcel);

			// æ‰¹é‡æ“ä½œäº‹ä»¶
			document
				.getElementById('batchDeleteBtn')
				.addEventListener('click', batchDelete);
			document
				.getElementById('batchCopyBtn')
				.addEventListener('click', batchCopy);
			document
				.getElementById('batchMoveBtn')
				.addEventListener('click', batchCut);

			// ç‚¹å‡»ç©ºç™½å¤„å…³é—­å³é”®èœå•
			document.addEventListener('click', (e) => {
				if (!contextMenu.contains(e.target)) {
					contextMenu.style.display = 'none';
					currentContextItem = null;
				}
			});

			// å³é”®èœå•ç‚¹å‡»äº‹ä»¶
			document
				.getElementById('menuOpen')
				.addEventListener('click', handleMenuOpen);
			document
				.getElementById('menuRename')
				.addEventListener('click', handleMenuRename);
			document
				.getElementById('menuDelete')
				.addEventListener('click', handleMenuDelete);
			document
				.getElementById('menuNewFolder')
				.addEventListener('click', handleMenuNewFolder);
			document
				.getElementById('menuNewFile')
				.addEventListener('click', handleMenuNewFile);
			document
				.getElementById('menuCopy')
				.addEventListener('click', handleMenuCopy);
			document
				.getElementById('menuCut')
				.addEventListener('click', handleMenuCut);
			document
				.getElementById('menuPaste')
				.addEventListener('click', handleMenuPaste);

			// åˆå§‹åŒ–å“åº”å¼ä¾§è¾¹æ 
			initResponsiveSidebar();
			// åˆå§‹åŒ–æ‹–æ‹½ä¸Šä¼ 
			initDragUpload();
			// åˆå§‹åŒ–å‰ªè´´æ¿æç¤º
			initClipboardTip();

			// åˆ‡æ¢è§†å›¾æ¨¡å¼
			function switchViewMode(mode) {
				currentViewMode = mode;
				document
					.getElementById('cardViewBtn')
					.classList.toggle('active', mode === 'card');
				document
					.getElementById('listViewBtn')
					.classList.toggle('active', mode === 'list');
				// æ–°å¢ï¼šæ§åˆ¶å¯¼å‡ºæŒ‰é’®æ˜¾ç¤º
				document.getElementById('exportExcelBtn').style.display =
					mode === 'list' ? 'block' : 'none';
				filterAndRenderFiles();
			}

			// æ˜¾ç¤ºåŠ è½½åŠ¨ç”»
			function showLoading(message = 'åŠ è½½ä¸­...') {
				const overlay = document.getElementById('loadingOverlay');
				overlay.style.display = 'flex';
				overlay.querySelector('.loading-text').textContent = message;
			}

			// éšè—åŠ è½½åŠ¨ç”»
			function hideLoading() {
				const overlay = document.getElementById('loadingOverlay');
				overlay.style.display = 'none';
			}

			// åŠ è½½è·¯å¾„æ•°æ®ï¼ˆè¿‡æ»¤~$æ–‡ä»¶ï¼‰
			async function loadPathData() {
				const inputPath = document
					.getElementById('pathInput')
					.value.trim();
				if (!inputPath) return alert('è¯·è¾“å…¥æœ‰æ•ˆçš„æ–‡ä»¶å¤¹è·¯å¾„ï¼');

				showLoading();
				try {
					const safePath = inputPath.replace(/\//g, '\\');
					const res = await fetch(`${baseUrl}/getFiles`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ targetPath: safePath }),
					});
					const data = await res.json();

					if (data.code === 0) {
						currentPath = data.data.currentPath;
						parentPath = data.data.parentPath;

						// è¿‡æ»¤~$å¼€å¤´æ–‡ä»¶
						const filteredDirs = data.data.dirs.filter(
							(dir) => !dir.name.startsWith('~$')
						);
						const filteredFiles = data.data.files.filter(
							(file) => !file.name.startsWith('~$')
						);

						fileDataCache[currentPath] = {
							dirs: filteredDirs,
							files: filteredFiles,
							items: [
								...filteredDirs.map((d) => ({
									...d,
									type: 'dir',
								})),
								...filteredFiles.map((f) => ({
									...f,
									type: 'file',
								})),
							],
						};
						sortConfig = {
							field: '',
							direction: '',
							original: [...fileDataCache[currentPath].items],
						};
						searchKeyword = '';
						document.getElementById('searchInput').value = '';

						document.getElementById(
							'pathBar'
						).textContent = `å½“å‰è·¯å¾„ï¼š${currentPath}`;
						const isRoot = currentPath === parentPath;
						document.getElementById('backBtnSidebar').disabled =
							isRoot;
						document.getElementById('backBtnContent').disabled =
							isRoot;

						renderTree(currentPath);
						filterAndRenderFiles();
					} else {
						showError(data.msg);
					}
				} catch (err) {
					showError(`åŠ è½½å¤±è´¥ï¼š${err.message}`);
				} finally {
					hideLoading();
				}
			}
			// å¯¼å‡ºExcel
			async function exportToExcel() {
				if (!currentPath || !fileDataCache[currentPath]) {
					alert('æš‚æ— æ•°æ®å¯å¯¼å‡º');
					return;
				}

				showLoading('æ­£åœ¨ç”ŸæˆExcelæ–‡ä»¶...');
				try {
					// è·å–å½“å‰ç­›é€‰åçš„æ–‡ä»¶åˆ—è¡¨
					let items = [...fileDataCache[currentPath].items];
					if (searchKeyword) {
						items = items.filter((item) =>
							item.name.toLowerCase().includes(searchKeyword)
						);
					}
					items = sortFiles(
						items,
						sortConfig.field,
						sortConfig.direction
					);

					// è½¬æ¢æ•°æ®æ ¼å¼
					const exportData = items.map((item) => ({
						æ–‡ä»¶å: item.name,
						ç±»å‹: item.type === 'dir' ? 'æ–‡ä»¶å¤¹' : 'æ–‡ä»¶',
						å¤§å°:
							item.type === 'dir'
								? '-'
								: formatFileSize(item.size),
						ä¿®æ”¹æ—¶é—´: item.mtime,
						è·¯å¾„: item.path,
					}));

					// ========== ä¼˜åŒ–ï¼šç®€åŒ–æ–‡ä»¶åï¼Œé¿å…ç‰¹æ®Šå­—ç¬¦ ==========
					// è·å–çº¯å­—æ¯/æ•°å­—çš„æ–‡ä»¶å¤¹åï¼ˆæ›¿æ¢ç‰¹æ®Šå­—ç¬¦ï¼‰
					const folderName = pathUtils
						.basename(currentPath)
						.replace(/[^\w\u4e00-\u9fa5]/g, '_') // æ›¿æ¢éå­—æ¯/æ•°å­—/ä¸­æ–‡ä¸ºä¸‹åˆ’çº¿
						.substring(0, 20); // é™åˆ¶é•¿åº¦
					const fileName = `æ–‡ä»¶åˆ—è¡¨_${folderName}_${new Date().getTime()}`;
					// ===================================================

					// è°ƒç”¨åç«¯æ¥å£ç”Ÿæˆå¹¶ä¸‹è½½Excel
					const res = await fetch(`${baseUrl}/exportExcel`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							data: exportData,
							fileName: fileName,
						}),
					});

					// å¤„ç†æ–‡ä»¶ä¸‹è½½
					const blob = await res.blob();
					const url = window.URL.createObjectURL(blob);
					const a = document.createElement('a');
					a.href = url;
					// å‰ç«¯ä¸‹è½½æ—¶çš„æ–‡ä»¶åï¼ˆæµè§ˆå™¨ä¼šè‡ªåŠ¨è§£ç ï¼‰
					a.download = `æ–‡ä»¶åˆ—è¡¨_${folderName}.xlsx`;
					document.body.appendChild(a);
					a.click();
					window.URL.revokeObjectURL(url);
					document.body.removeChild(a);

					hideLoading();
					alert('Excelå¯¼å‡ºæˆåŠŸï¼');
				} catch (err) {
					hideLoading();
					alert(`å¯¼å‡ºå¤±è´¥ï¼š${err.message}`);
				}
			}

			// é€’å½’æ¸²æŸ“ç›®å½•æ ‘
			function renderTree(path) {
				const treeContainer = document.getElementById('dirTree');
				const data = fileDataCache[path];
				if (!data)
					return (treeContainer.innerHTML =
						'<div class="error-tip">è·¯å¾„æ•°æ®æœªåŠ è½½</div>');

				treeContainer.innerHTML = '';
				const allItems = [
					...data.dirs.map((d) => ({ ...d, type: 'dir' })),
					...data.files.map((f) => ({ ...f, type: 'file' })),
				];
				if (allItems.length === 0)
					return (treeContainer.innerHTML =
						'<div class="empty-tip">å½“å‰è·¯å¾„æ— æ–‡ä»¶å’Œç›®å½•</div>');

				allItems.forEach((item, index) => {
					const wrapper = createTreeNodeWrapper(
						index === allItems.length - 1
					);
					const node = createTreeNode(item, path);
					wrapper.appendChild(node);

					if (item.type === 'dir') {
						const childrenContainer = document.createElement('div');
						childrenContainer.className = 'tree-children';
						childrenContainer.dataset.path = item.path;
						wrapper.appendChild(childrenContainer);

						const toggleIcon = node.querySelector('.toggle-icon');
						toggleIcon.addEventListener('click', async (e) => {
							e.stopPropagation();
							const isShow =
								childrenContainer.classList.toggle('show');
							toggleIcon.textContent = isShow ? '-' : '+';

							if (isShow && !childrenContainer.innerHTML) {
								try {
									const childRes = await fetch(
										`${baseUrl}/getFiles`,
										{
											method: 'POST',
											headers: {
												'Content-Type':
													'application/json',
											},
											body: JSON.stringify({
												targetPath: item.path,
											}),
										}
									);
									const childData = await childRes.json();

									if (childData.code === 0) {
										const filteredChildDirs =
											childData.data.dirs.filter(
												(dir) =>
													!dir.name.startsWith('~$')
											);
										const filteredChildFiles =
											childData.data.files.filter(
												(file) =>
													!file.name.startsWith('~$')
											);

										fileDataCache[item.path] = {
											dirs: filteredChildDirs,
											files: filteredChildFiles,
											items: [
												...filteredChildDirs.map(
													(d) => ({
														...d,
														type: 'dir',
													})
												),
												...filteredChildFiles.map(
													(f) => ({
														...f,
														type: 'file',
													})
												),
											],
										};

										const childItems = [
											...filteredChildDirs.map((d) => ({
												...d,
												type: 'dir',
											})),
											...filteredChildFiles.map((f) => ({
												...f,
												type: 'file',
											})),
										];

										if (childItems.length === 0) {
											childrenContainer.innerHTML =
												'<div class="empty-tip" style="padding-left: 10px; font-size: 12px;">æ— ä¸‹çº§æ–‡ä»¶å’Œç›®å½•</div>';
											return;
										}

										childItems.forEach(
											(childItem, childIndex) => {
												const childWrapper =
													createTreeNodeWrapper(
														childIndex ===
															childItems.length -
																1
													);
												const childNode =
													createTreeNode(
														childItem,
														item.path
													);
												childWrapper.appendChild(
													childNode
												);

												if (childItem.type === 'dir') {
													const grandChildContainer =
														document.createElement(
															'div'
														);
													grandChildContainer.className =
														'tree-children';
													grandChildContainer.dataset.path =
														childItem.path;
													childWrapper.appendChild(
														grandChildContainer
													);

													const childToggle =
														childNode.querySelector(
															'.toggle-icon'
														);
													childToggle.addEventListener(
														'click',
														async (e) => {
															e.stopPropagation();
															const isGrandShow =
																grandChildContainer.classList.toggle(
																	'show'
																);
															childToggle.textContent =
																isGrandShow
																	? '-'
																	: '+';

															if (
																isGrandShow &&
																!grandChildContainer.innerHTML
															) {
																try {
																	const grandRes =
																		await fetch(
																			`${baseUrl}/getFiles`,
																			{
																				method: 'POST',
																				headers:
																					{
																						'Content-Type':
																							'application/json',
																					},
																				body: JSON.stringify(
																					{
																						targetPath:
																							childItem.path,
																					}
																				),
																			}
																		);
																	const grandData =
																		await grandRes.json();

																	if (
																		grandData.code ===
																		0
																	) {
																		const filteredGrandDirs =
																			grandData.data.dirs.filter(
																				(
																					dir
																				) =>
																					!dir.name.startsWith(
																						'~$'
																					)
																			);
																		const filteredGrandFiles =
																			grandData.data.files.filter(
																				(
																					file
																				) =>
																					!file.name.startsWith(
																						'~$'
																					)
																			);

																		fileDataCache[
																			childItem.path
																		] = {
																			dirs: filteredGrandDirs,
																			files: filteredGrandFiles,
																			items: [
																				...filteredGrandDirs.map(
																					(
																						d
																					) => ({
																						...d,
																						type: 'dir',
																					})
																				),
																				...filteredGrandFiles.map(
																					(
																						f
																					) => ({
																						...f,
																						type: 'file',
																					})
																				),
																			],
																		};

																		const grandItems =
																			[
																				...filteredGrandDirs.map(
																					(
																						d
																					) => ({
																						...d,
																						type: 'dir',
																					})
																				),
																				...filteredGrandFiles.map(
																					(
																						f
																					) => ({
																						...f,
																						type: 'file',
																					})
																				),
																			];

																		if (
																			grandItems.length ===
																			0
																		) {
																			grandChildContainer.innerHTML =
																				'<div class="empty-tip" style="padding-left: 10px; font-size: 12px;">æ— ä¸‹çº§æ–‡ä»¶å’Œç›®å½•</div>';
																			return;
																		}

																		grandItems.forEach(
																			(
																				grandItem,
																				grandIndex
																			) => {
																				const grandWrapper =
																					createTreeNodeWrapper(
																						grandIndex ===
																							grandItems.length -
																								1
																					);
																				const grandNode =
																					createTreeNode(
																						grandItem,
																						childItem.path
																					);
																				grandWrapper.appendChild(
																					grandNode
																				);
																				grandChildContainer.appendChild(
																					grandWrapper
																				);
																			}
																		);
																	}
																} catch (err) {
																	grandChildContainer.innerHTML = `<div class="error-tip" style="padding-left: 10px; font-size: 12px;">åŠ è½½å¤±è´¥ï¼š${err.message}</div>`;
																}
															}
														}
													);
												}

												childrenContainer.appendChild(
													childWrapper
												);
											}
										);
									}
								} catch (err) {
									childrenContainer.innerHTML = `<div class="error-tip" style="padding-left: 10px; font-size: 12px;">åŠ è½½å¤±è´¥ï¼š${err.message}</div>`;
								}
							}
						});
					}

					treeContainer.appendChild(wrapper);
				});
			}

			// åˆ›å»ºç›®å½•æ ‘èŠ‚ç‚¹åŒ…è£…å™¨
			function createTreeNodeWrapper(isLast) {
				const wrapper = document.createElement('div');
				wrapper.className = 'tree-node-wrapper';
				if (isLast) wrapper.classList.add('last-node');
				return wrapper;
			}

			// åˆ›å»ºç›®å½•/æ–‡ä»¶èŠ‚ç‚¹
			function createTreeNode(item, parentPath) {
				const node = document.createElement('div');
				node.className = `tree-node ${item.type}`;
				node.dataset.path = item.path;
				node.dataset.type = item.type;
				node.dataset.name = item.name;

				const icon =
					item.type === 'dir'
						? '<i class="node-icon fa-solid fa-folder"></i>'
						: getFileIcon(item.name);
				const toggleIcon =
					item.type === 'dir'
						? '<span class="toggle-icon">+</span>'
						: '<span class="toggle-icon"></span>';

				node.innerHTML = `
                ${toggleIcon}
                ${icon}
                <span class="node-name">${item.name}</span>
            `;

				// å•å‡»é€‰ä¸­
				node.addEventListener('click', (e) => {
					if (e.ctrlKey) {
						// å¤šé€‰æ¨¡å¼
						toggleSelection(item, node);
					} else {
						// å•é€‰æ¨¡å¼
						clearAllSelections();
						node.classList.add('active');
						// åŒæ­¥å³ä¾§é€‰ä¸­çŠ¶æ€
						syncSelectionToRight(item.path);
					}
				});

				// åŒå‡»æ‰“å¼€
				node.addEventListener('dblclick', (e) => {
					e.stopPropagation();
					handleItemOpen(item);
				});

				// å³é”®èœå•
				node.addEventListener('contextmenu', (e) => {
					e.preventDefault();
					currentContextItem = item;
					showContextMenu(e.clientX, e.clientY, false);
				});

				return node;
			}

			// åŒæ­¥é€‰ä¸­çŠ¶æ€åˆ°å³ä¾§é¢æ¿
			function syncSelectionToRight(path) {
				// æ¸…é™¤å³ä¾§åŸæœ‰é€‰ä¸­
				document
					.querySelectorAll(
						'.file-item-card.selected, .file-list-list tr.selected'
					)
					.forEach((el) => {
						el.classList.remove('selected');
					});

				// é€‰ä¸­å³ä¾§å¯¹åº”é¡¹
				const targetItem = document.querySelector(
					`[data-path="${path}"]`
				);
				if (targetItem) {
					targetItem.classList.add('selected');
					// æ›´æ–°é€‰ä¸­æ•°ç»„
					selectedItems = [
						{
							path: path,
							type: targetItem.dataset.type,
							name: targetItem.dataset.name,
						},
					];
					updateBatchActions();
				}
			}

			// å¤„ç†å¤šé€‰
			function toggleSelection(item, element) {
				const index = selectedItems.findIndex(
					(i) => i.path === item.path
				);
				if (index > -1) {
					selectedItems.splice(index, 1);
					element.classList.remove('selected', 'active');
				} else {
					selectedItems.push(item);
					element.classList.add('selected', 'active');
				}

				updateBatchActions();
			}

			// æ¸…é™¤æ‰€æœ‰é€‰ä¸­çŠ¶æ€
			function clearAllSelections() {
				document
					.querySelectorAll(
						'.file-item-card.selected, .file-list-list tr.selected, .tree-node.active, .tree-node.selected'
					)
					.forEach((el) => {
						el.classList.remove('selected', 'active');
					});
				selectedItems = [];
				updateBatchActions();
			}

			// æ›´æ–°æ‰¹é‡æ“ä½œæŒ‰é’®
			function updateBatchActions() {
				const batchActions = document.getElementById('batchActions');
				const countElement = document.querySelector(
					'.batch-count strong'
				);

				if (countElement) {
					countElement.textContent = selectedItems.length;
				}

				if (batchActions) {
					batchActions.style.display =
						selectedItems.length > 0 ? 'flex' : 'none';
				}
			}

			// è¿‡æ»¤å¹¶æ¸²æŸ“æ–‡ä»¶
			function filterAndRenderFiles() {
				if (!currentPath || !fileDataCache[currentPath]) return;

				let items = [...fileDataCache[currentPath].items];
				if (searchKeyword)
					items = items.filter((item) =>
						item.name.toLowerCase().includes(searchKeyword)
					);
				items = sortFiles(
					items,
					sortConfig.field,
					sortConfig.direction
				);

				if (items.length === 0) {
					const tip = searchKeyword
						? '<div class="search-empty-tip">æœªæ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶/ç›®å½•</div>'
						: '<div class="empty-tip">å½“å‰è·¯å¾„æ— æ–‡ä»¶å’Œç›®å½•</div>';
					document.getElementById('fileDisplayArea').innerHTML = tip;
					// ç»‘å®šç©ºç™½å¤„å³é”®äº‹ä»¶
					document
						.getElementById('fileDisplayArea')
						.addEventListener(
							'contextmenu',
							handleBlankContextMenu
						);
					return;
				}

				renderFiles(items);
			}

			// æ’åºæ–‡ä»¶
			function sortFiles(items, field, direction) {
				if (!field || !direction) return items;

				const sorted = [...items];
				switch (field) {
					case 'name':
						sorted.sort((a, b) =>
							direction === 'asc'
								? a.name
										.toLowerCase()
										.localeCompare(b.name.toLowerCase())
								: b.name
										.toLowerCase()
										.localeCompare(a.name.toLowerCase())
						);
						break;
					case 'size':
						sorted.sort((a, b) => {
							const sizeA = a.type === 'dir' ? 0 : a.size;
							const sizeB = b.type === 'dir' ? 0 : b.size;
							return direction === 'asc'
								? sizeA - sizeB
								: sizeB - sizeA;
						});
						break;
					case 'mtime':
						sorted.sort((a, b) => {
							const timeA = new Date(a.mtime).getTime();
							const timeB = new Date(b.mtime).getTime();
							return direction === 'asc'
								? timeA - timeB
								: timeB - timeA;
						});
						break;
					case 'type':
						sorted.sort((a, b) => {
							if (a.type !== b.type)
								return direction === 'asc'
									? a.type === 'dir'
										? -1
										: 1
									: a.type === 'dir'
									? 1
									: -1;
							return a.name
								.toLowerCase()
								.localeCompare(b.name.toLowerCase());
						});
						break;
				}
				return sorted;
			}

			// åˆ‡æ¢æ’åºçŠ¶æ€
			function toggleSort(field) {
				document
					.querySelectorAll('.file-list-list th')
					.forEach((th) => {
						if (th.dataset.field !== field) {
							th.classList.remove('active');
							th.querySelector('.sort-arrow').textContent = '';
						}
					});

				const th = document.querySelector(`th[data-field="${field}"]`);
				const arrow = th.querySelector('.sort-arrow');

				if (sortConfig.field !== field) {
					sortConfig.field = field;
					sortConfig.direction = 'asc';
					th.classList.add('active');
					arrow.textContent = 'â†‘';
				} else if (sortConfig.direction === 'asc') {
					sortConfig.direction = 'desc';
					arrow.textContent = 'â†“';
				} else {
					sortConfig.field = '';
					sortConfig.direction = '';
					th.classList.remove('active');
					arrow.textContent = '';
				}

				filterAndRenderFiles();
			}

			// æ¸²æŸ“å³ä¾§æ–‡ä»¶ï¼ˆä½¿ç”¨ç¬¬ä¸‰æ–¹å›¾æ ‡+ç§»é™¤æ“ä½œæŒ‰é’®ï¼‰
			function renderFiles(items) {
				const displayArea = document.getElementById('fileDisplayArea');
				// å…ˆç§»é™¤æ—§çš„ç©ºç™½å¤„å³é”®äº‹ä»¶ï¼Œé¿å…é‡å¤ç»‘å®š
				displayArea.removeEventListener(
					'contextmenu',
					handleBlankContextMenu
				);
				// é‡æ–°ç»‘å®šç©ºç™½å¤„å³é”®äº‹ä»¶
				displayArea.addEventListener(
					'contextmenu',
					handleBlankContextMenu
				);

				if (currentViewMode === 'card') {
					let html = '<div class="file-list-card">';
					items.forEach((item) => {
						const icon =
							item.type === 'dir'
								? '<i class="item-icon dir fa-solid fa-folder"></i>'
								: getFileIcon(item.name, 'item-icon');
						html += `
                        <div class="file-item-card ${item.type}" data-path="${item.path}" data-type="${item.type}" data-name="${item.name}">
                            ${icon}
                            <div class="item-name">${item.name}</div>
                        </div>
                    `;
					});
					html += '</div>';
					displayArea.innerHTML = html;

					// ç»‘å®šå¡ç‰‡äº‹ä»¶ï¼ˆä»…å³é”®èœå•æ“ä½œï¼‰
					document
						.querySelectorAll('.file-item-card')
						.forEach((card) => {
							const item = {
								path: card.dataset.path,
								type: card.dataset.type,
								name: card.dataset.name,
							};

							// å•å‡»é€‰ä¸­
							card.addEventListener('click', (e) => {
								if (e.ctrlKey) {
									// å¤šé€‰æ¨¡å¼
									toggleSelection(item, card);
								} else {
									// å•é€‰æ¨¡å¼
									clearAllSelections();
									card.classList.add('selected');
									// åŒæ­¥å·¦ä¾§é€‰ä¸­çŠ¶æ€
									syncSelectionToLeft(item.path);
								}
							});

							// åŒå‡»æ‰“å¼€
							card.addEventListener('dblclick', () => {
								handleItemOpen(item);
							});

							// å³é”®èœå•
							card.addEventListener('contextmenu', (e) => {
								e.preventDefault();
								e.stopPropagation();
								currentContextItem = item;
								showContextMenu(e.clientX, e.clientY, false);
							});
						});
				} else {
					let html = `
                    <table class="file-list-list">
                        <thead>
                            <tr>
                                <th data-field="type">ç±»å‹ <span class="sort-arrow"></span></th>
                                <th data-field="name">åç§° <span class="sort-arrow"></span></th>
                                <th data-field="size">å¤§å° <span class="sort-arrow"></span></th>
                                <th data-field="mtime">ä¿®æ”¹æ—¶é—´ <span class="sort-arrow"></span></th>
                            </tr>
                        </thead>
                        <tbody>
                `;
					items.forEach((item) => {
						const icon =
							item.type === 'dir'
								? '<i class="list-item-icon dir fa-solid fa-folder"></i>'
								: getFileIcon(item.name, 'list-item-icon');
						const fileSize =
							item.type === 'dir'
								? '-'
								: formatFileSize(item.size);
						html += `
                        <tr class="${item.type}" data-path="${item.path}" data-type="${item.type}" data-name="${item.name}">
                            <td>${icon}</td>
                            <td>${item.name}</td>
                            <td class="file-size">${fileSize}</td>
                            <td class="file-mtime">${item.mtime}</td>
                        </tr>
                    `;
					});
					html += `
                        </tbody>
                    </table>
                `;
					displayArea.innerHTML = html;

					// ç»‘å®šåˆ—è¡¨äº‹ä»¶ï¼ˆä»…å³é”®èœå•æ“ä½œï¼‰
					document
						.querySelectorAll('.file-list-list tr')
						.forEach((row) => {
							if (!row.dataset.path) return;

							const item = {
								path: row.dataset.path,
								type: row.dataset.type,
								name: row.dataset.name,
							};

							// å•å‡»é€‰ä¸­
							row.addEventListener('click', (e) => {
								if (e.ctrlKey) {
									// å¤šé€‰æ¨¡å¼
									toggleSelection(item, row);
								} else {
									// å•é€‰æ¨¡å¼
									clearAllSelections();
									row.classList.add('selected');
									// åŒæ­¥å·¦ä¾§é€‰ä¸­çŠ¶æ€
									syncSelectionToLeft(item.path);
								}
							});

							// åŒå‡»æ‰“å¼€
							row.addEventListener('dblclick', () => {
								handleItemOpen(item);
							});

							// å³é”®èœå•
							row.addEventListener('contextmenu', (e) => {
								e.preventDefault();
								e.stopPropagation();
								currentContextItem = item;
								showContextMenu(e.clientX, e.clientY, false);
							});
						});

					// ç»‘å®šæ’åºäº‹ä»¶
					document
						.querySelectorAll('.file-list-list th')
						.forEach((th) => {
							if (th.dataset.field) {
								th.addEventListener('click', () =>
									toggleSort(th.dataset.field)
								);
							}
						});
				}
			}

			// åŒæ­¥é€‰ä¸­çŠ¶æ€åˆ°å·¦ä¾§ç›®å½•æ ‘
			function syncSelectionToLeft(path) {
				// æ¸…é™¤å·¦ä¾§åŸæœ‰é€‰ä¸­
				document
					.querySelectorAll('.tree-node.active, .tree-node.selected')
					.forEach((el) => {
						el.classList.remove('active', 'selected');
					});

				// é€‰ä¸­å·¦ä¾§å¯¹åº”é¡¹
				const targetNode = document.querySelector(
					`.tree-node[data-path="${path}"]`
				);
				if (targetNode) {
					targetNode.classList.add('active');
				}
			}

			// æ ¹æ®æ–‡ä»¶åè·å–å¯¹åº”å›¾æ ‡ï¼ˆFont Awesomeï¼‰
			function getFileIcon(fileName, prefix) {
				const ext = fileName.split('.').pop().toLowerCase();
				const classPrefix = prefix
					? `${prefix} file `
					: 'node-icon file ';

				switch (ext) {
					case 'txt':
						return `<i class="${classPrefix}txt fa-solid fa-file-lines"></i>`;
					case 'doc':
					case 'docx':
						return `<i class="${classPrefix}doc fa-solid fa-file-word"></i>`;
					case 'xls':
					case 'xlsx':
						return `<i class="${classPrefix}xls fa-solid fa-file-excel"></i>`;
					case 'ppt':
					case 'pptx':
						return `<i class="${classPrefix}ppt fa-solid fa-file-powerpoint"></i>`;
					case 'pdf':
						return `<i class="${classPrefix}pdf fa-solid fa-file-pdf"></i>`;
					case 'png':
					case 'jpg':
					case 'jpeg':
					case 'gif':
					case 'bmp':
					case 'svg':
						return `<i class="${classPrefix}img fa-regular fa-file-image"></i>`;
					case 'mp4':
					case 'avi':
					case 'mov':
					case 'wmv':
					case 'flv':
						return `<i class="${classPrefix}video fa-solid fa-file-video"></i>`;
					case 'mp3':
					case 'wav':
					case 'flac':
					case 'aac':
					case 'ogg':
						return `<i class="${classPrefix}audio fa-solid fa-file-audio"></i>`;
					case 'zip':
					case 'rar':
					case '7z':
					case 'tar':
					case 'gz':
						return `<i class="${classPrefix}archive fa-solid fa-file-zipper"></i>`;
					case 'js':
					case 'ts':
					case 'jsx':
					case 'tsx':
						return `<i class="${classPrefix}code fa-solid fa-file-code"></i>`;
					case 'html':
					case 'htm':
						return `<i class="${classPrefix}html fa-solid fa-file-code"></i>`;
					case 'css':
						return `<i class="${classPrefix}css fa-solid fa-file-code"></i>`;
					default:
						return `<i class="${classPrefix}default fa-solid fa-file"></i>`;
				}
			}

			// æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
			function formatFileSize(bytes) {
				if (bytes === 0) return '0 B';
				const k = 1024;
				const sizes = ['B', 'KB', 'MB', 'GB'];
				const i = Math.floor(Math.log(bytes) / Math.log(k));
				return (
					parseFloat((bytes / Math.pow(k, i)).toFixed(2)) +
					' ' +
					sizes[i]
				);
			}

			// è¿”å›ä¸Šçº§ç›®å½•
			function goBack() {
				if (currentPath !== parentPath) {
					document.getElementById('pathInput').value = parentPath;
					loadPathData();
				}
			}

			// æ‰“å¼€æ–‡ä»¶/ç›®å½•
			function handleItemOpen(item) {
				if (item.type === 'dir') {
					document.getElementById('pathInput').value = item.path;
					loadPathData();
				} else {
					openFile(item.path);
				}
			}

			// æ‰“å¼€æ–‡ä»¶
			async function openFile(path) {
				try {
					const res = await fetch(`${baseUrl}/openFile`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ targetPath: path }),
					});
					const data = await res.json();
					if (data.code !== 0) alert(data.msg);
				} catch (err) {
					alert(`æ‰“å¼€æ–‡ä»¶å¤±è´¥ï¼š${err.message}`);
				}
			}

			// æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
			function showError(msg) {
				document.getElementById(
					'fileDisplayArea'
				).innerHTML = `<div class="error-tip">${msg}</div>`;
				document.getElementById(
					'dirTree'
				).innerHTML = `<div class="error-tip">${msg}</div>`;
				document.getElementById('pathBar').textContent =
					'å½“å‰è·¯å¾„ï¼šåŠ è½½å¤±è´¥';
			}

			// æ˜¾ç¤ºå³é”®èœå•
			function showContextMenu(x, y, isBlank) {
				// 1. ç‚¹å‡»æ–‡ä»¶/ç›®å½•ï¼ˆisBlank=falseï¼‰ï¼šæ˜¾ç¤ºã€æ‰“å¼€ã€é‡å‘½åã€åˆ é™¤ã€‘ï¼Œéšè—ã€æ–°å»ºã€‘
				if (!isBlank) {
					document.getElementById('menuOpen').style.display = 'flex';
					document.getElementById('menuRename').style.display =
						'flex';
					document.getElementById('menuDelete').style.display =
						'flex';
					document.getElementById('menuNewFolder').style.display =
						'none';
					document.getElementById('menuNewFile').style.display =
						'none';

					// æ˜¾ç¤ºå¤åˆ¶/å‰ªåˆ‡/ç²˜è´´é€‰é¡¹
					document.getElementById('menuCopy').style.display = 'flex';
					document.getElementById('menuCut').style.display = 'flex';
					document.getElementById('menuPaste').style.display =
						clipboard ? 'flex' : 'none';
				}
				// 2. ç‚¹å‡»ç©ºç™½å¤„ï¼ˆisBlank=trueï¼‰ï¼šéšè—ã€æ‰“å¼€ã€é‡å‘½åã€åˆ é™¤ã€‘ï¼Œæ˜¾ç¤ºã€æ–°å»ºã€‘
				else {
					document.getElementById('menuOpen').style.display = 'none';
					document.getElementById('menuRename').style.display =
						'none';
					document.getElementById('menuDelete').style.display =
						'none';
					document.getElementById('menuNewFolder').style.display =
						'flex';
					document.getElementById('menuNewFile').style.display =
						'flex';

					// æ˜¾ç¤ºç²˜è´´é€‰é¡¹ï¼ˆå¦‚æœæœ‰å‰ªè´´æ¿å†…å®¹ï¼‰
					document.getElementById('menuPaste').style.display =
						clipboard ? 'flex' : 'none';
					document.getElementById('menuCopy').style.display = 'none';
					document.getElementById('menuCut').style.display = 'none';
				}

				// å¤„ç†èœå•è¶…å‡ºå±å¹•çš„æƒ…å†µ
				const menu = document.getElementById('contextMenu');
				const windowWidth = window.innerWidth;
				const windowHeight = window.innerHeight;
				const menuWidth = menu.offsetWidth;
				const menuHeight = menu.offsetHeight;

				// æ°´å¹³ä½ç½®ä¿®æ­£
				let left = x;
				if (x + menuWidth > windowWidth) {
					left = x - menuWidth;
				}
				// å‚ç›´ä½ç½®ä¿®æ­£
				let top = y;
				if (y + menuHeight > windowHeight) {
					top = y - menuHeight;
				}

				// è®¾ç½®èœå•ä½ç½®å¹¶æ˜¾ç¤º
				menu.style.left = `${left}px`;
				menu.style.top = `${top}px`;
				menu.style.display = 'block';
			}

			// ç©ºç™½å¤„å³é”®äº‹ä»¶å¤„ç†
			function handleBlankContextMenu(e) {
				e.preventDefault();
				currentContextItem = null;
				showContextMenu(e.clientX, e.clientY, true);
			}

			// èœå•-æ‰“å¼€
			function handleMenuOpen() {
				if (currentContextItem) {
					handleItemOpen(currentContextItem);
					contextMenu.style.display = 'none';
				}
			}

			// èœå•-é‡å‘½å
			async function handleMenuRename() {
				if (!currentContextItem) return;

				const newName = prompt(
					'è¯·è¾“å…¥æ–°åç§°ï¼š',
					currentContextItem.name
				);
				if (!newName || newName === currentContextItem.name) return;
				if (newName.startsWith('~$')) {
					alert('ä¸èƒ½åˆ›å»ºä»¥~$å¼€å¤´çš„æ–‡ä»¶/ç›®å½•ï¼');
					return;
				}

				// æ„é€ æ–°è·¯å¾„
				const dirPath = pathUtils.dirname(currentContextItem.path);
				const newFilePath = pathUtils.join(dirPath, newName);

				// å‘é€é‡å‘½åè¯·æ±‚
				const res = await fetch(`${baseUrl}/rename`, {
					method: 'POST',
					headers: { 'Content-Type': 'application/json' },
					body: JSON.stringify({
						oldPath: currentContextItem.path,
						newPath: newFilePath,
					}),
				});
				const data = await res.json();

				if (data.code === 0) {
					alert('é‡å‘½åæˆåŠŸ');
					loadPathData(); // é‡æ–°åŠ è½½å½“å‰ç›®å½•
				} else {
					alert(`é‡å‘½åå¤±è´¥ï¼š${data.msg}`);
				}

				contextMenu.style.display = 'none';
			}

			// èœå•-åˆ é™¤
			async function handleMenuDelete() {
				if (!currentContextItem) return;

				if (confirm(`ç¡®å®šè¦åˆ é™¤ ${currentContextItem.name} å—ï¼Ÿ`)) {
					// å‘é€åˆ é™¤è¯·æ±‚
					const res = await fetch(`${baseUrl}/delete`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							targetPath: currentContextItem.path,
						}),
					});
					const data = await res.json();

					if (data.code === 0) {
						alert('åˆ é™¤æˆåŠŸ');
						loadPathData(); // é‡æ–°åŠ è½½å½“å‰
					} else {
						alert(`åˆ é™¤å¤±è´¥ï¼š${data.msg}`);
					}
				}
				contextMenu.style.display = 'none';
			}

			// èœå•-æ–°å»ºæ–‡ä»¶å¤¹
			async function handleMenuNewFolder() {
				const folderName = prompt('è¯·è¾“å…¥æ–°æ–‡ä»¶å¤¹åç§°ï¼š', 'æ–°å»ºæ–‡ä»¶å¤¹');
				if (!folderName) return;
				if (folderName.startsWith('~$')) {
					alert('ä¸èƒ½åˆ›å»ºä»¥~$å¼€å¤´çš„æ–‡ä»¶å¤¹ï¼');
					return;
				}

				const newFolderPath = pathUtils.join(currentPath, folderName);
				showLoading('åˆ›å»ºæ–‡ä»¶å¤¹ä¸­...');

				try {
					const res = await fetch(`${baseUrl}/newFolder`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ targetPath: newFolderPath }),
					});
					const data = await res.json();
					if (data.code === 0) {
						alert('æ–‡ä»¶å¤¹åˆ›å»ºæˆåŠŸ');
						loadPathData();
					} else {
						alert(`åˆ›å»ºå¤±è´¥ï¼š${data.msg}`);
					}
				} catch (err) {
					alert(`åˆ›å»ºå¤±è´¥ï¼š${err.message}`);
				} finally {
					hideLoading();
				}
				contextMenu.style.display = 'none';
			}

			// èœå•-æ–°å»ºæ–‡ä»¶
			async function handleMenuNewFile() {
				const fileName = prompt(
					'è¯·è¾“å…¥æ–°æ–‡ä»¶åç§°ï¼ˆå«æ‰©å±•åï¼‰ï¼š',
					'æ–°å»ºæ–‡ä»¶.txt'
				);
				if (!fileName) return;
				if (fileName.startsWith('~$')) {
					alert('ä¸èƒ½åˆ›å»ºä»¥~$å¼€å¤´çš„æ–‡ä»¶ï¼');
					return;
				}

				const newFilePath = pathUtils.join(currentPath, fileName);
				showLoading('åˆ›å»ºæ–‡ä»¶ä¸­...');

				try {
					const res = await fetch(`${baseUrl}/newFile`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({ targetPath: newFilePath }),
					});
					const data = await res.json();
					if (data.code === 0) {
						alert('æ–‡ä»¶åˆ›å»ºæˆåŠŸ');
						loadPathData();
					} else {
						alert(`åˆ›å»ºå¤±è´¥ï¼š${data.msg}`);
					}
				} catch (err) {
					alert(`åˆ›å»ºå¤±è´¥ï¼š${err.message}`);
				} finally {
					hideLoading();
				}
				contextMenu.style.display = 'none';
			}

			// èœå•-å¤åˆ¶
			function handleMenuCopy() {
				if (!currentContextItem) return;
				clipboard = currentContextItem;
				clipboardAction = 'copy';
				showClipboardTip('å·²å¤åˆ¶ï¼š' + currentContextItem.name);
				contextMenu.style.display = 'none';
			}

			// èœå•-å‰ªåˆ‡
			function handleMenuCut() {
				if (!currentContextItem) return;
				clipboard = currentContextItem;
				clipboardAction = 'cut';
				showClipboardTip('å·²å‰ªåˆ‡ï¼š' + currentContextItem.name);
				contextMenu.style.display = 'none';
			}

			// èœå•-ç²˜è´´
			async function handleMenuPaste() {
				if (!clipboard) return;

				const targetPath = pathUtils.join(currentPath, clipboard.name);
				showLoading(
					clipboardAction === 'copy' ? 'å¤åˆ¶ä¸­...' : 'ç§»åŠ¨ä¸­...'
				);

				try {
					const res = await fetch(`${baseUrl}/${clipboardAction}`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							sourcePath: clipboard.path,
							targetPath: targetPath,
						}),
					});
					const data = await res.json();
					if (data.code === 0) {
						alert(
							clipboardAction === 'copy' ? 'å¤åˆ¶æˆåŠŸ' : 'ç§»åŠ¨æˆåŠŸ'
						);
						loadPathData();
						// å‰ªåˆ‡åæ¸…ç©ºå‰ªè´´æ¿
						if (clipboardAction === 'cut') {
							clipboard = null;
							clipboardAction = null;
						}
					} else {
						alert(
							`${
								clipboardAction === 'copy' ? 'å¤åˆ¶' : 'ç§»åŠ¨'
							}å¤±è´¥ï¼š${data.msg}`
						);
					}
				} catch (err) {
					alert(
						`${clipboardAction === 'copy' ? 'å¤åˆ¶' : 'ç§»åŠ¨'}å¤±è´¥ï¼š${
							err.message
						}`
					);
				} finally {
					hideLoading();
				}
				contextMenu.style.display = 'none';
			}

			// æ‰¹é‡åˆ é™¤
			async function batchDelete() {
				if (selectedItems.length === 0) return;
				if (!confirm(`ç¡®å®šè¦åˆ é™¤é€‰ä¸­çš„ ${selectedItems.length} é¡¹å—ï¼Ÿ`))
					return;

				showLoading('æ‰¹é‡åˆ é™¤ä¸­...');
				try {
					const res = await fetch(`${baseUrl}/batchDelete`, {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify({
							paths: selectedItems.map((item) => item.path),
						}),
					});
					const data = await res.json();
					if (data.code === 0) {
						alert('æ‰¹é‡åˆ é™¤æˆåŠŸ');
						loadPathData();
						clearAllSelections();
					} else {
						alert(`æ‰¹é‡åˆ é™¤å¤±è´¥ï¼š${data.msg}`);
					}
				} catch (err) {
					alert(`æ‰¹é‡åˆ é™¤å¤±è´¥ï¼š${err.message}`);
				} finally {
					hideLoading();
				}
			}

			// æ‰¹é‡å¤åˆ¶
			function batchCopy() {
				if (selectedItems.length === 0) return;
				clipboard = selectedItems;
				clipboardAction = 'copy';
				showClipboardTip(`å·²å¤åˆ¶ ${selectedItems.length} é¡¹`);
			}

			// æ‰¹é‡å‰ªåˆ‡
			function batchCut() {
				if (selectedItems.length === 0) return;
				clipboard = selectedItems;
				clipboardAction = 'cut';
				showClipboardTip(`å·²å‰ªåˆ‡ ${selectedItems.length} é¡¹`);
			}

			// æ˜¾ç¤ºå‰ªè´´æ¿æç¤º
			function showClipboardTip(message) {
				const tip = document.getElementById('clipboardTip');
				tip.textContent = message;
				tip.style.display = 'block';
				setTimeout(() => {
					tip.style.display = 'none';
				}, 2000);
			}

			// åˆå§‹åŒ–å‰ªè´´æ¿æç¤º
			function initClipboardTip() {
				const tip = document.getElementById('clipboardTip');
				tip.style.display = 'none';
			}

			// åˆå§‹åŒ–æ‹–æ‹½ä¸Šä¼ 
			function initDragUpload() {
				const contentArea = document.querySelector('.content');
				contentArea.addEventListener('dragover', (e) => {
					e.preventDefault();
					contentArea.classList.add('dragover');
				});

				contentArea.addEventListener('dragleave', () => {
					contentArea.classList.remove('dragover');
				});

				contentArea.addEventListener('drop', async (e) => {
					e.preventDefault();
					contentArea.classList.remove('dragover');
					if (!e.dataTransfer.files.length) return;

					showLoading('ä¸Šä¼ ä¸­...');
					const formData = new FormData();
					for (let file of e.dataTransfer.files) {
						formData.append('files', file);
					}
					formData.append('targetPath', currentPath);

					try {
						const res = await fetch(`${baseUrl}/upload`, {
							method: 'POST',
							body: formData,
						});
						const data = await res.json();
						if (data.code === 0) {
							alert(`æˆåŠŸä¸Šä¼  ${data.data.count} ä¸ªæ–‡ä»¶`);
							loadPathData();
						} else {
							alert(`ä¸Šä¼ å¤±è´¥ï¼š${data.msg}`);
						}
					} catch (err) {
						alert(`ä¸Šä¼ å¤±è´¥ï¼š${err.message}`);
					} finally {
						hideLoading();
					}
				});
			}

			// åˆå§‹åŒ–å“åº”å¼ä¾§è¾¹æ 
			function initResponsiveSidebar() {
				const toggleBtn = document.getElementById('sidebarToggle');
				const sidebar = document.getElementById('sidebar');
				toggleBtn.addEventListener('click', () => {
					sidebar.style.width =
						sidebar.style.width === '380px' ? '0' : '380px';
				});
			}
		</script>
	</body>
</html>
